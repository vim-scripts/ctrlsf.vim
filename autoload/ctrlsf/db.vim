" ============================================================================
" Description: An ack/ag powered code search and view tool.
" Author: Ye Ding <dygvirus@gmail.com>
" Licence: Vim licence
" Version: 1.20
" ============================================================================

" List of paragraphs, paragraph is main object which stores parsed query result
let s:resultset = []

" cache contains ALL cacheable result
let s:cache = {}

"""""""""""""""""""""""""""""""""
" Getter
"""""""""""""""""""""""""""""""""
func! ctrlsf#db#ResultSet() abort
    return s:resultset
endf

func! ctrlsf#db#FileSet() abort
    " List of result files, generated by resultset
    let fileset   = []

    if has_key(s:cache, 'fileset')
        return s:cache['fileset']
    endif

    let cur_file = ''
    for par in s:resultset
        if cur_file !=# par.file
            let cur_file = par.file
            call add(fileset, {
                \ "file": cur_file,
                \ "paragraphs": [],
                \ })
        endif
        call add(fileset[-1].paragraphs, par)
    endfo

    let s:cache['fileset'] = fileset
    return fileset
endf

func! ctrlsf#db#MatchList() abort
    " List of matches, generated by resultset
    let matchlist = []

    if has_key(s:cache, 'matchlist')
        return s:cache['matchlist']
    endif

    for par in s:resultset
        call extend(matchlist, par.matches())
    endfo

    let s:cache['matchlist'] = matchlist
    return matchlist
endf

func! ctrlsf#db#MaxLnum()
    if has_key(s:cache, 'maxlnum')
        return s:cache['maxlnum']
    endif

    let max = 0
    for par in s:resultset
        let mlnum = par.lnum() + par.range() - 1
        let max = mlnum > max ? mlnum : max
    endfo

    let s:cache['maxlnum'] = max
    return max
endf

"""""""""""""""""""""""""""""""""
" Parser
"""""""""""""""""""""""""""""""""
" s:DefactorizeLine()
"
" Defactorize result line into [filename, line_number, content].
"
" Expected input is like 'autoload/ctrlsf.vim:182-endif', where '-' serves as
" delimiter.
"
" Note: A subtle difference exists between ack's result and ag's, delimiter
" between path and line number is always ':' in ag, but varies in ack
" depending on whether this line matches.
"
func! s:DefactorizeLine(line, fname_guess) abort
    " filename
    let filename = ''

    if a:fname_guess !=# ''
            \ && stridx(a:line, a:fname_guess) == 0
            \ && match(a:line, '^[-:]\d\+[-:]', strlen(a:fname_guess)) != -1
        let filename = a:fname_guess
    else
        let fname_end = 0
        while fname_end != -1
            let fname_end = match(a:line, '[-:]\d\+[-:]', fname_end + 1)
            let possible_fname = strpart(a:line, 0, fname_end)

            " check possible filename aginst actual file to verify
            if filereadable(possible_fname) && !isdirectory(possible_fname)
                let filename = possible_fname
                break
            endif
        endwh
    endif

    " line number
    let lnum = matchstr(a:line, '\d\+', strlen(filename))

    " content
    let content = strpart(a:line, strlen(filename) + strlen(lnum) + 2)

    call ctrlsf#log#Debug(
                \ "DefactorizeLine: [Factor]: [%s, %s, %s], [Orig]: %s",
                \ filename, lnum, content, a:line)

    return [filename, lnum, content]
endf

" s:NewParagraph()
"
" Create a paragraph object based on parsed lines. Acceptable argument
" 'buffer' is a list of defactorized line [fname, lnum, content].
"
" Notice that some fields are initialized with -1, which will be populated
" in render processing.
"
func! s:NewParagraph(buffer) abort
    let paragraph = {
        \ 'file'    : a:buffer[0][0],
        \ 'lnum'    : function("ctrlsf#class#paragraph#Lnum"),
        \ 'vlnum'   : function("ctrlsf#class#paragraph#Vlnum"),
        \ 'range'   : function("ctrlsf#class#paragraph#Range"),
        \ 'lines'   : [],
        \ 'matches' : function("ctrlsf#class#paragraph#Matches"),
        \ }

    for [fname, lnum, content] in a:buffer
        " add matched line to match list
        let match = {}
        let mat_col = match(content, ctrlsf#opt#GetOpt("_vimregex")) + 1
        if mat_col > 0
            let match = {
                \ 'lnum'  : lnum,
                \ 'vlnum' : -1,
                \ 'col'   : mat_col,
                \ 'vcol'  : -1
                \ }
        endif

        " add line content
        call add(paragraph.lines, {
            \ 'matched' : function("ctrlsf#class#line#Matched"),
            \ 'match'   : match,
            \ 'lnum'    : lnum,
            \ 'vlnum'   : -1,
            \ 'content' : content,
            \ })
    endfo

    return paragraph
endf

" ParseAckprgResult()
"
func! ctrlsf#db#ParseAckprgResult(result) abort
    " reset
    let s:resultset = []
    call ctrlsf#db#ClearCache()

    " in case of mixed text from win-style files and unix-style files, breaks
    " result into lines by both <CR><NL> and <NL>.
    let result_lines = split(a:result, '\v(\r\n)|\n')

    let current_file = ""
    let cur          = 0

    while cur < len(result_lines)
        let buffer = []
        let next_file = ''
        let pre_ln    = -1

        while cur < len(result_lines)
            let line = result_lines[cur]
            let cur += 1

            " don't rely on division line any longer. ignore it.
            if line =~ '^--$' || line =~ '^$'
                continue
            endif

            let [fname, lnum, content] = s:DefactorizeLine(line, current_file)

            if fname !=# current_file
                let next_file = fname
                let cur -= 1
                break
            endif

            if (pre_ln == -1) || (lnum == pre_ln + 1)
                let pre_ln = lnum
                call add(buffer, [fname, lnum, content])
            else
                let cur -= 1
                break
            endif
        endwh

        if len(buffer) > 0
            let paragraph = s:NewParagraph(buffer)
            call add(s:resultset, paragraph)
        endif

        let current_file = next_file
    endwh
endf

"""""""""""""""""""""""""""""""""
" Cache
"""""""""""""""""""""""""""""""""
" ClearCache
"
func! ctrlsf#db#ClearCache() abort
    let s:cache = {}
endf
